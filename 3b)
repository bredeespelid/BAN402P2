# Sets
set TEAMS;
set VENUES;
set DATES ordered;
set GROUPS;
set MATCHES;
set SEEDED_MATCHES;

# Parameters
param distance{VENUES, VENUES};  # Distance between venues
param group{TEAMS};  # Group of each team
param match_date{MATCHES};  # Date of each match
param matches_per_venue{VENUES};  # Maximum number of matches per venue
param team1{MATCHES} symbolic;  # First team in each match
param team2{MATCHES} symbolic;  # Second team in each match
param seeded_match_venue{SEEDED_MATCHES} symbolic;  # Venue for seeded matches
param seeded_match_date{SEEDED_MATCHES};  # Date for seeded matches
param venue_schedule{VENUES, DATES};
param germany_matches{MATCHES, VENUES};
var MaxTravel;  # Maximum travel distance among all teams
var MinTravel;  # Minimum travel distance among all teams


# Variables
var x{MATCHES, VENUES} binary;  # If match m is played in venue v
var y{TEAMS, MATCHES, MATCHES, VENUES, VENUES} binary;  # Binary variable to link two matches for travel distance
var travel{TEAMS} >= 0;  # Total travel distance for each team

param alpha := 0.5;  # Weight for total distance
param beta := 0.5;   # Weight for fairness (can adjust these weights as needed)
minimize CombinedObjective:
    alpha * sum{t in TEAMS} travel[t] + beta * (MaxTravel - MinTravel);

# Each match is assigned to exactly one venue
subject to MatchAssignment {m in MATCHES}:
    sum{v in VENUES} x[m,v] = 1;

# All matches must be assigned
subject to AllMatchesAssigned:
    sum{m in MATCHES, v in VENUES} x[m,v] = card(MATCHES);

# Each venue can host at most the number of matches assigned to it in the real schedule
subject to MatchesPerVenue {v in VENUES}:
    sum{m in MATCHES} x[m,v] <= matches_per_venue[v];

# Ensure at least two days of rest between matches at the same venue
subject to VenueMaintenance {v in VENUES, d in DATES: ord(d) < card(DATES)-1}:
    sum{m in MATCHES: match_date[m] = d or match_date[m] = next(d)} x[m,v] <= 1;

# Ensure group games are distributed across at least four venues
subject to GroupGamesDistribution {g in GROUPS}:
    sum{v in VENUES} (if sum{m in MATCHES: group[team1[m]] = g or group[team2[m]] = g} x[m,v] > 0 then 1 else 0) >= 4;

# No venue can host more than two matches for the same group
subject to MaxGroupGamesPerVenue {v in VENUES, g in GROUPS}:
    sum{m in MATCHES: group[team1[m]] = g or group[team2[m]] = g} x[m,v] <= 2;

# Ensure all venues host at least one match by 18 June
subject to EarlyGameAllVenues:
    sum{v in VENUES} (if sum{m in MATCHES: match_date[m] <= 18} x[m,v] > 0 then 1 else 0) >= card(VENUES) - 2;

# Ensure all venues host at least one match on or after 24 June
subject to LateGameAllVenues:
    sum{v in VENUES} (if sum{m in MATCHES: match_date[m] >= 24} x[m,v] > 0 then 1 else 0) >= card(VENUES) - 2;

subject to VenueSchedule {v in VENUES, d in DATES}:
    sum{m in MATCHES: match_date[m] = d} x[m,v] >= venue_schedule[v,d] - 1;

subject to GermanyGames {m in MATCHES, v in VENUES: germany_matches[m,v] = 1}:
    x[m,v] = 1;

# Binary linking travel between consecutive matches (linearization constraints)
subject to LinkY1 {t in TEAMS, m1 in MATCHES, m2 in MATCHES, v1 in VENUES, v2 in VENUES: 
    (team1[m1] = t or team2[m1] = t) and (team1[m2] = t or team2[m2] = t) and match_date[m1] < match_date[m2]}:
    y[t,m1,m2,v1,v2] <= x[m1,v1];

subject to LinkY2 {t in TEAMS, m1 in MATCHES, m2 in MATCHES, v1 in VENUES, v2 in VENUES: 
    (team1[m1] = t or team2[m1] = t) and (team1[m2] = t or team2[m2] = t) and match_date[m1] < match_date[m2]}:
    y[t,m1,m2,v1,v2] <= x[m2,v2];

subject to LinkY3 {t in TEAMS, m1 in MATCHES, m2 in MATCHES, v1 in VENUES, v2 in VENUES: 
    (team1[m1] = t or team2[m1] = t) and (team1[m2] = t or team2[m2] = t) and match_date[m1] < match_date[m2]}:
    y[t,m1,m2,v1,v2] >= x[m1,v1] + x[m2,v2] - 1;

subject to TravelDistance {t in TEAMS}:
    travel[t] = sum{m1 in MATCHES, m2 in MATCHES, v1 in VENUES, v2 in VENUES:
        (team1[m1] = t or team2[m1] = t) and 
        (team1[m2] = t or team2[m2] = t) and 
        match_date[m1] < match_date[m2] and 
        forall {m3 in MATCHES: match_date[m1] < match_date[m3] < match_date[m2]}
            ((team1[m3] != t) and (team2[m3] != t))}
    distance[v1,v2] * y[t,m1,m2,v1,v2];
    
# Constraints for max and min travel distances
subject to MaxTravelConstraint {t in TEAMS}:
    MaxTravel >= travel[t];

subject to MinTravelConstraint {t in TEAMS}:
    MinTravel <= travel[t];
    
